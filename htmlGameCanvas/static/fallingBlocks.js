!function(){console.log("Loading window.fallingBlocks..."),window.fallingBlocks=this,this.gameApi=void 0,this.init=gameApi=>{this.gameApi=gameApi,this.initControls(),this.initLayers(),console.log("...fallingBlocks initialized"),this.gameApi.startGame()},this.keyEnter=13,this.keyEsc=27,this.keySpace=32,this.keyLeft=37,this.keyUp=38,this.keyRight=39,this.keyDown=40,this.gameData={active:!0,conf:{cols:14,rows:20,blockSize:33,headerSize:70,timer:40,completeTimer:25,completeColor:"gainsboro",gameOverColor:"darkred",gameColor:"black",headerColor:"midnightblue",headerFont:"16px sans-serif"},colors:["blue","green","red","magenta","yellow","cyan","darkgrey"],shapes:{line:[[0,-1,0,0,0,1,0,2],[-2,0,-1,0,0,0,1,0],[0,-1,0,0,0,1,0,2],[-2,0,-1,0,0,0,1,0]],square:[[0,0,0,1,1,0,1,1],[0,0,0,1,1,0,1,1],[0,0,0,1,1,0,1,1],[0,0,0,1,1,0,1,1]],left_l:[[0,-1,0,0,0,1,1,1],[-1,1,-1,0,0,0,1,0],[-1,-1,0,-1,0,0,0,1],[-1,0,0,0,1,0,1,-1]],right_l:[[-1,1,0,1,0,0,0,-1],[-1,0,-1,1,0,1,1,1],[1,-1,0,-1,0,0,0,1],[-1,0,0,0,1,0,1,1]],left_z:[[0,-1,0,0,1,0,1,1],[-1,1,0,1,0,0,1,0],[0,-1,0,0,1,0,1,1],[-1,1,0,1,0,0,1,0]],right_z:[[1,-1,1,0,0,0,0,1],[-1,0,0,0,0,1,1,1],[1,-1,1,0,0,0,0,1],[-1,0,0,0,0,1,1,1]],tee:[[0,-1,0,0,0,1,1,0],[-1,0,0,0,1,0,0,1],[0,-1,0,0,0,1,-1,0],[-1,0,0,0,1,0,0,-1]]},gameOver:!1,keysPressed:[],all:[],complete:[],completeCount:0,curr:void 0,next:void 0,score:0},this.initControls=()=>{this.gameApi.keys([this.keyEnter,this.keyEsc,this.keySpace,this.keyUp,this.keyDown,this.keyLeft,this.keyRight]),this.gameApi.inputCallback(this.handleKeypress),console.log("Setup controls for game canvas engine = "+JSON.stringify(this.gameApi.config().input.keys))},this.initLayers=()=>{const width=this.gameApi.config().canvas.width=this.gameData.conf.cols*this.gameData.conf.blockSize,height=this.gameApi.config().canvas.height=this.gameData.conf.rows*this.gameData.conf.blockSize+this.gameData.conf.headerSize;console.log("Width/Height for game canvas engine = "+width+":"+height);const layer={think:this.thinkLayer,render:this.renderLayer,data:this.gameData};this.gameApi.addLayer(layer),console.log("Added object to html game canvas engine")},this.resetGameOver=()=>{this.gameData.gameOver=!1,this.gameData.score=0,this.gameData.curr=void 0,this.gameData.next=void 0,this.gameData.all=[]},this.handleKeypress=keys=>{const keypress=keys.at(0)||-1;keypress===this.keyEsc?this.handleStartStop(!0):keypress===this.keyEnter?this.handleStartStop(this.gameData.active):this.gameData.keysPressed.push(keypress)},this.handleStartStop=stop=>{stop?(this.gameData.active=!1,this.gameApi.stopGame()):(this.gameData.gameOver&&this.resetGameOver(),this.gameData.active=!0,this.gameApi.startGame())},this.handleKeypressMovement=(keypress,data)=>{if(data&&data.curr)if(keypress===this.keyUp||keypress==this.keySpace){const nextOrientation=data.curr.orientation+1;this.checkShapeBounds({...data.curr,orientation:nextOrientation},data.all)?console.log("keypress: CANNOT move left, another block or boundary in the way"):data.curr.orientation=nextOrientation}else if(keypress===this.keyDown)data.curr.timer=0;else if(keypress===this.keyLeft){const nextPx=data.curr.px-1;this.checkShapeBounds({...data.curr,px:nextPx},data.all)?console.log("keypress: CANNOT move left, another block or boundary in the way"):data.curr.px=nextPx}else if(keypress===this.keyRight){const nextPx=data.curr.px+1;this.checkShapeBounds({...data.curr,px:nextPx},data.all)?console.log("keypress: CANNOT move right, another block or boundary in the way"):data.curr.px=nextPx}else console.log("keypress: UNKNOWN ",keypress)},this.thinkLayer=(idx,count,data)=>{if(data.gameOver)return data.active=!1,void this.gameApi.stopGame();this.gameData.keysPressed.length>0&&(this.gameData.keysPressed.forEach((k=>this.handleKeypressMovement(k,data))),this.gameData.keysPressed=[]),this.handleCompleteLines(data),data.next||(data.next=this.newBlock()),data.curr||(data.curr=data.next,data.next=void 0),data.curr.timer--<=0&&this.handleAutoFallTimer(data)},this.handleAutoFallTimer=data=>{const nextPy=data.curr.py+1;if(!1===this.checkShapeBounds({...data.curr,py:nextPy},data.all))data.curr.py=nextPy,data.curr.timer=this.gameData.conf.timer;else{const{px,py}=this.startingPosition();px===data.curr.px&&py===data.curr.py?(console.log("locked in starting startingPosition, game over"),data.gameOver=!0):(this.lockShape(data),data.curr=data.next,data.next=void 0)}},this.handleCompleteLines=data=>{data.completeCount>0&&(data.completeCount--,console.log("decrement completeCount =",data.completeCount),data.completeCount<=0&&data.complete.length>0&&(data.complete.forEach((py=>this.handleCompleteRow(data,py))),data.complete=[]))},this.handleCompleteRow=(data,py)=>{console.log("removing row py =",py),console.log("total blocks before removal =",data.all.length),data.all=data.all.filter((block=>block.py!==py)).map((block=>(block.py<py&&(block.py=block.py+1),block))),console.log("total blocks after removal =",data.all.length)},this.checkCompleteLines=data=>{let linesComplete=0;for(py=0;py<data.conf.rows;py++)console.log("checking complete for py =",py),this.checkCompleteRow(data,py)&&(console.log("mark complete for py =",py),this.markCompleteRow(data,py),linesComplete++);linesComplete>0&&(this.addScore(100*linesComplete),linesComplete>2&&this.addScore(1e3*(linesComplete-2)))},this.checkCompleteRow=(data,py)=>{const pxs=data.all.filter((block=>block.py===py)).map((block=>block.px));for(px=0;px<data.conf.cols;px++)if(!pxs.includes(px))return!1;return!0},this.markCompleteRow=(data,py)=>{data.all.filter((block=>block.py===py)).forEach((block=>{block.color=data.conf.completeColor})),data.complete.push(py),data.completeCount=data.conf.completeTimer},this.checkShapeBounds=(block,all)=>{const shape=this.gameData.shapes[`${block.shape}`],xys=shape[block.orientation%shape.length];block.color;let shapeBounds=!1;for(skip=0;skip<8&&!shapeBounds;skip+=2){let px=block.px+xys[0+skip],py=block.py+xys[1+skip];shapeBounds=checkBounds(px,py,all)}return shapeBounds},this.checkBounds=(px,py,all)=>{if(py>=this.gameData.conf.rows||px<0||px>=this.gameData.conf.cols)return!0;if(Array.isArray(all)){return all.filter((b=>b.py===py&&b.px===px)).length>0}return!1},this.lockShape=data=>{const shape=data.shapes[`${data.curr.shape}`],xys=shape[data.curr.orientation%shape.length];for(skip=0;skip<8;skip+=2){let px=data.curr.px+xys[0+skip],py=data.curr.py+xys[1+skip];data.all.push({px,py,color:data.curr.color})}this.addScore(5),this.checkCompleteLines(data)},this.addScore=plusScore=>{this.gameData.score+=plusScore},this.newColor=()=>this.gameData.colors[this.gameApi.random(this.gameData.colors.length)],this.newShape=()=>{const shapes=Object.keys(this.gameData.shapes);return shapes[this.gameApi.random(123456789)%shapes.length]},this.startingPosition=()=>({px:this.gameData.conf.cols/2-1,py:0}),this.newBlock=()=>{const{px,py}=this.startingPosition();return{px,py,color:this.newColor(),shape:this.newShape(),orientation:0,timer:this.gameData.conf.timer}},this.renderShape=(ctx,block,blockSize)=>{const shape=this.gameData.shapes[`${block.shape}`],xys=shape[block.orientation%shape.length],color=block.color;for(skip=0;skip<8;skip+=2){let px=block.px+xys[0+skip],py=block.py+xys[1+skip];renderBlock(ctx,{color,px,py},blockSize)}},this.renderBlock=(ctx,block,blockSize)=>{this.gameApi.drawUtil({type:"rect",c:block.color,x:block.px*blockSize,y:block.py*blockSize+this.gameData.conf.headerSize,dx:blockSize,dy:blockSize})},this.renderHeader=(ctx,conf,color)=>{if(this.gameApi.drawUtil({type:"rect",c:color,x:0,y:0,dx:conf.cols*conf.blockSize,dy:conf.headerSize}),ctx.fillStyle="white",ctx.font=conf.headerFont,ctx.fillText("Score: "+this.gameData.score,conf.cols*conf.blockSize*.7,.9*conf.headerSize),this.gameData.gameOver)ctx.fillText("G A M E  O V E R ! !",10,.9*conf.headerSize);else if(this.gameData.next){ctx.fillText("Next:",10,.9*conf.headerSize);const nextShape={orientation:1,color:this.gameData.next.color,shape:this.gameData.next.shape,px:3,py:-2};this.renderShape(ctx,nextShape,conf.blockSize)}},this.renderBackground=(ctx,conf,color)=>{this.gameApi.drawUtil({type:"rect",c:color,x:0,y:0,dx:conf.cols*conf.blockSize,dy:conf.rows*conf.blockSize+conf.headerSize})},this.renderLayer=(idx,count,data,ctx)=>{data.gameOver?this.renderBackground(ctx,data.conf,data.conf.gameOverColor):this.renderBackground(ctx,data.conf,data.conf.gameColor),this.renderHeader(ctx,data.conf,data.conf.headerColor),data.all.forEach((d=>this.renderBlock(ctx,d,data.conf.blockSize))),data.curr&&this.renderShape(ctx,data.curr,data.conf.blockSize)}}();